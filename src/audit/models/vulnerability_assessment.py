"""
VulnerabilityAssessment model - Technical analysis of security weaknesses
Provides CVSS 3.1 component analysis and exploit scenarios for findings
"""
from dataclasses import dataclass, field
from typing import List, Optional
from uuid import uuid4
from enum import Enum


class AttackVector(Enum):
    """CVSS 3.1 Attack Vector values"""
    LOCAL = "Local"
    NETWORK = "Network" 
    PHYSICAL = "Physical"
    ADJACENT = "Adjacent"


class AttackComplexity(Enum):
    """CVSS 3.1 Attack Complexity values"""
    LOW = "Low"
    HIGH = "High"


class PrivilegesRequired(Enum):
    """CVSS 3.1 Privileges Required values"""
    NONE = "None"
    LOW = "Low"
    HIGH = "High"


class UserInteraction(Enum):
    """CVSS 3.1 User Interaction values"""
    NONE = "None"
    REQUIRED = "Required"


class Scope(Enum):
    """CVSS 3.1 Scope values"""
    UNCHANGED = "Unchanged"
    CHANGED = "Changed"


class Impact(Enum):
    """CVSS 3.1 Impact values (Confidentiality, Integrity, Availability)"""
    NONE = "None"
    LOW = "Low"
    HIGH = "High"


@dataclass
class VulnerabilityAssessment:
    """
    Technical analysis entity with CVSS 3.1 component scoring
    Belongs to one AuditFinding (many-to-one relationship)
    """
    # Required fields
    finding_id: str
    attack_vector: AttackVector
    attack_complexity: AttackComplexity
    privileges_required: PrivilegesRequired
    user_interaction: UserInteraction
    scope: Scope
    confidentiality_impact: Impact
    integrity_impact: Impact
    availability_impact: Impact
    
    # Optional fields
    id: str = field(default_factory=lambda: str(uuid4()))
    exploitability_score: Optional[float] = None
    impact_score: Optional[float] = None
    proof_of_concept: Optional[str] = None
    prerequisites: List[str] = field(default_factory=list)
    limitations: List[str] = field(default_factory=list)
    
    def __post_init__(self):
        """Calculate CVSS component scores and validate assessment"""
        self._validate_finding_id()
        self._calculate_scores()
        self._validate_proof_of_concept()
    
    def _validate_finding_id(self):
        """Validate finding_id references existing AuditFinding"""
        if not self.finding_id or not isinstance(self.finding_id, str):
            raise ValueError("Finding ID must be non-empty string")
        
        # UUID format validation
        import re
        uuid_pattern = r'^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$'
        if not re.match(uuid_pattern, self.finding_id, re.IGNORECASE):
            raise ValueError(f"Finding ID must be valid UUID format: {self.finding_id}")
    
    def _calculate_scores(self):
        """Calculate CVSS 3.1 exploitability and impact scores"""
        # CVSS 3.1 base score calculation from specification
        
        # Attack Vector scoring
        av_scores = {
            AttackVector.NETWORK: 0.85,
            AttackVector.ADJACENT: 0.62,
            AttackVector.LOCAL: 0.55,
            AttackVector.PHYSICAL: 0.2
        }
        
        # Attack Complexity scoring
        ac_scores = {
            AttackComplexity.LOW: 0.77,
            AttackComplexity.HIGH: 0.44
        }
        
        # Privileges Required scoring (depends on scope)
        if self.scope == Scope.UNCHANGED:
            pr_scores = {
                PrivilegesRequired.NONE: 0.85,
                PrivilegesRequired.LOW: 0.62,
                PrivilegesRequired.HIGH: 0.27
            }
        else:  # CHANGED
            pr_scores = {
                PrivilegesRequired.NONE: 0.85,
                PrivilegesRequired.LOW: 0.68,
                PrivilegesRequired.HIGH: 0.50
            }
        
        # User Interaction scoring
        ui_scores = {
            UserInteraction.NONE: 0.85,
            UserInteraction.REQUIRED: 0.62
        }
        
        # Impact scoring
        impact_scores = {
            Impact.HIGH: 0.56,
            Impact.LOW: 0.22,
            Impact.NONE: 0.0
        }
        
        # Calculate exploitability score
        self.exploitability_score = (
            8.22 * av_scores[self.attack_vector] * 
            ac_scores[self.attack_complexity] *
            pr_scores[self.privileges_required] *
            ui_scores[self.user_interaction]
        )
        
        # Calculate impact subscore
        isc_base = (
            1 - (1 - impact_scores[self.confidentiality_impact]) *
            (1 - impact_scores[self.integrity_impact]) *
            (1 - impact_scores[self.availability_impact])
        )
        
        if self.scope == Scope.UNCHANGED:
            self.impact_score = 6.42 * isc_base
        else:  # CHANGED
            self.impact_score = 7.52 * (isc_base - 0.029) - 3.25 * pow(isc_base - 0.02, 15)
    
    def _validate_proof_of_concept(self):
        """Validate proof of concept is provided for high-impact vulnerabilities"""
        # From validation rules: PoC required for Critical/High severity findings
        # Note: We don't have direct access to finding severity here, so this is a placeholder
        # In real implementation, this would query the associated AuditFinding
        pass
    
    def calculate_base_score(self) -> float:
        """Calculate CVSS 3.1 base score from component scores"""
        if self.impact_score <= 0:
            return 0.0
        
        if self.scope == Scope.UNCHANGED:
            base_score = min(self.impact_score + self.exploitability_score, 10.0)
        else:  # CHANGED
            base_score = min(1.08 * (self.impact_score + self.exploitability_score), 10.0)
        
        # Round up to nearest tenth
        import math
        return math.ceil(base_score * 10) / 10
    
    def get_severity_from_score(self, base_score: float) -> str:
        """Map CVSS base score to severity level"""
        if 9.0 <= base_score <= 10.0:
            return "Critical"
        elif 7.0 <= base_score <= 8.9:
            return "High"
        elif 4.0 <= base_score <= 6.9:
            return "Medium"
        elif 0.1 <= base_score <= 3.9:
            return "Low"
        else:  # 0.0
            return "Info"
    
    def to_dict(self) -> dict:
        """Convert assessment to dictionary for JSON serialization"""
        return {
            "id": self.id,
            "finding_id": self.finding_id,
            "attack_vector": self.attack_vector.value,
            "attack_complexity": self.attack_complexity.value,
            "privileges_required": self.privileges_required.value,
            "user_interaction": self.user_interaction.value,
            "scope": self.scope.value,
            "confidentiality_impact": self.confidentiality_impact.value,
            "integrity_impact": self.integrity_impact.value,
            "availability_impact": self.availability_impact.value,
            "exploitability_score": self.exploitability_score,
            "impact_score": self.impact_score,
            "base_score": self.calculate_base_score(),
            "proof_of_concept": self.proof_of_concept,
            "prerequisites": self.prerequisites,
            "limitations": self.limitations
        }
    
    @classmethod
    def from_dict(cls, data: dict) -> 'VulnerabilityAssessment':
        """Create assessment from dictionary (JSON deserialization)"""
        return cls(
            id=data["id"],
            finding_id=data["finding_id"],
            attack_vector=AttackVector(data["attack_vector"]),
            attack_complexity=AttackComplexity(data["attack_complexity"]),
            privileges_required=PrivilegesRequired(data["privileges_required"]),
            user_interaction=UserInteraction(data["user_interaction"]),
            scope=Scope(data["scope"]),
            confidentiality_impact=Impact(data["confidentiality_impact"]),
            integrity_impact=Impact(data["integrity_impact"]),
            availability_impact=Impact(data["availability_impact"]),
            exploitability_score=data.get("exploitability_score"),
            impact_score=data.get("impact_score"),
            proof_of_concept=data.get("proof_of_concept"),
            prerequisites=data.get("prerequisites", []),
            limitations=data.get("limitations", [])
        )